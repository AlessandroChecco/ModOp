/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/

(function(e){function n(r){if(t[r])return t[r].exports;var i=t[r]={exports:{},id:r,loaded:!1};return e[r].call(i.exports,i,i.exports,n),i.loaded=!0,i.exports}var t={};return n.m=e,n.c=t,n.p="",n(0)})({0:function(e,t,n){n(204)(n(205))},204:function(module,exports){module.exports=function(src){typeof execScript=="function"?execScript(src):eval.call(null,src)}},205:function(e,t){e.exports='function ImageAnnotation(jQuery,paper) {\n\n  // *canvas*\n  var MAX_VIEW_WIDTH = 548;\n  var MAX_VIEW_HEIGHT = 548;\n  var MAX_CHARACTERS = 50000;\n\n  // *globals*\n  var iaInstanceList = [];\n  var activeInstance = 0;\n\n  var DrawingToolConstants = {\n    DEFAULT: "default",\n    BRUSH: "brush",\n    DOT: "dot",\n    LINE: "line",\n    POLYGON: "polygon"\n  }\n\n  function IA_Instance(id) {\n    this.id = id;\n  }\n\n  IA_Instance.prototype.createSystems = function(tools) {\n    this.core = new InstanceCore(this.id,iaInstanceList[this.id]);\n    this.canvasCore = new CanvasCore(this.id,iaInstanceList[this.id]);\n    this.undoRedo = new UndoRedoSystem(this.id,iaInstanceList[this.id]);\n    this.preview = new PreviewSystem(this.id,iaInstanceList[this.id]);\n    this.saveLoad = new SaveLoadSystem(this.id,iaInstanceList[this.id]);\n    this.menu = new DrawingMenu(tools,this.id,iaInstanceList[this.id]);\n  }\n\n  var drawingToolConstantToObject = function(drawingToolConstant,instanceID,instance){\n    if(drawingToolConstant == DrawingToolConstants.POLYGON) {\n      return new PolygonDrawingTool(instanceID,instance);\n    }\n    else if(drawingToolConstant == DrawingToolConstants.BRUSH) {\n      return new BrushDrawingTool(instanceID,instance);\n    }\n    else if(drawingToolConstant == DrawingToolConstants.LINE) {\n      return new LineDrawingTool(instanceID,instance);\n    }\n    else if(drawingToolConstant == DrawingToolConstants.DOT) {\n      return new DotDrawingTool(instanceID,instance);\n    }\n    else {\n      return new DrawingTool(instanceID,instance);\n    }\n  }\n\n  function DrawingMenu(toolTypes,instanceID,instance) {\n    this.drawingTools = [];\n    this.id = instanceID;\n    this.instance = instance;\n    var activeTool = 0;\n    var emptyTool = null;\n\n    //initialize drawingTools\n    for(var i = 0; i < toolTypes.length; i++) {\n      this.drawingTools.push(drawingToolConstantToObject(toolTypes[i],this.id,this.instance));\n    }\n\n    this.getActiveTool = function() {\n      return this.drawingTools[activeTool];\n    }\n\n    this.areToolsEnabled = function() {\n      if(emptyTool != null) {\n        return false;\n      }\n      else {\n        return true;\n      }\n    }\n\n    this.setActiveTool = function(toolType) {\n      for(var i = 0; i < this.drawingTools.length; i++) {\n        if(this.drawingTools[i].getToolType() == toolType) {\n          activeTool = i;\n        }\n      }\n      return;\n    }\n\n    //creates an empty tool for the paper object to use\n    //this in turn disables all drawing functionality\n    this.disableActiveTool = function() {\n      if(emptyTool == null) {\n        emptyTool = new paper.Tool();\n      }\n      emptyTool.activate();\n    }\n\n    this.enableActiveTool = function() {\n      if(emptyTool != null) {\n        emptyTool.remove();\n        emptyTool = null;\n      }\n      this.drawingTools[activeTool].tool.activate();\n    }\n  }\n\n\n\n  DrawingMenu.prototype.getTool = function(toolType) {\n    for(var i =0; i < this.drawingTools.length; i++) {\n      if(this.drawingTools[i].getToolType() == toolType) {\n        return this.drawingTools[i];\n      }\n    }\n    return null;\n  }\n\n  DrawingMenu.prototype.redrawActiveTool = function() {\n    var $toolHtml = \'\';\n    var activeToolType = this.getActiveTool().getToolType();\n    for(var i = 0; i < this.drawingTools.length; i++) {\n      $toolHtml =  jQuery(\'.cf_action_list.ia_\'+this.id+\' .ia_\'+this.drawingTools[i].getToolType()+\'_tool\');\n      if(activeToolType == this.drawingTools[i].getToolType()) {\n        $toolHtml.removeClass(\'off\');\n        $toolHtml.addClass(\'on\');\n      }\n      else {\n        $toolHtml.removeClass(\'on\');\n        $toolHtml.addClass(\'off\');\n      }\n    }\n  }\n\n  DrawingMenu.prototype.initMenu = function() {\n    var iaContainer = jQuery(\'.ia_container.ia_\'+this.id);\n    iaContainer.prepend(this.toHtml());\n  }\n\n  DrawingMenu.prototype.addToolsToMenu = function() {\n    var htmlOutput = "";\n    var actionList = jQuery(".cf_action_list.ia_"+this.id);\n\n    var addToolIndexAndToolContainer = function(toolHtml,toolIndex,toolType) {\n      //add dummy parent so we can apply changes to all of toolHtml\n      var $newHtml = "<div>"+toolHtml+"</div>";\n\n      //add toolIndex to children\n      $newHtml = jQuery($newHtml).find(\'*\').each( function(c_index,child) {\n        jQuery(child).addClass("dm_"+toolIndex);\n      });\n\n      $newHtml =jQuery(\'<div>\').append($newHtml[0]).clone().html();\n      var finalHtmlString ="<div class=\'ia_"+toolType+"_tool\'>"+$newHtml+"</div>"\n\n      //add toolIndex to children\n      //return a string, not an html object\n      return finalHtmlString;\n    }\n\n    for(var i = 0; i < this.drawingTools.length; i++) {\n      htmlOutput += this.instance.core.makeHtmlForInstance(\n                      addToolIndexAndToolContainer(this.drawingTools[i].toHtml(),i,\n                        this.drawingTools[i].getToolType()));\n    }\n\n    jQuery(".cf_action_list.ia_"+this.id).prepend(htmlOutput);\n  }\n\n  DrawingMenu.prototype.toHtml = function() {\n    var htmlOutput = "";\n    htmlOutput += "<div class=\'cf_action_list ia_"+this.id+"\'>";\n      htmlOutput += "<div class=\'finished_msg\'>";\n        htmlOutput += "Saved";\n      htmlOutput += "</div>";\n      htmlOutput += "<div class=\'cf_object_list\'>";\n        htmlOutput += "<div class=\'path_list_title_container ia_"+this.id+"\'>";\n          htmlOutput += "<div class=\'path_list_title_text large_long_t_text ia_"+this.id+"\'>";\n            htmlOutput += "Drawn";\n          htmlOutput += "</div>";\n        htmlOutput += "</div>";\n        htmlOutput += "<div class=\'cf_path_list\'>";\n        htmlOutput += "</div>";\n      htmlOutput += "</div>";\n      htmlOutput += "<div class=\'cf_undo\'>";\n        htmlOutput += "Undo (ctrl + z)";\n      htmlOutput += "</div>";\n      htmlOutput += "<div class=\'cf_redo\'>";\n        htmlOutput += "Redo (ctrl + y)";\n      htmlOutput += "</div>";\n      htmlOutput += "<div class=\'render_holes\'>";\n        htmlOutput += "Preview";\n      htmlOutput += "</div>";\n      htmlOutput += "<div class=\'edit_holes\'>";\n        htmlOutput += "Back";\n      htmlOutput += "</div>";\n      htmlOutput += "<div class=\'done_drawing\'>";\n        htmlOutput += "Save";\n      htmlOutput += "</div>";\n      htmlOutput += "<div class=\'done_drawing_preview\'>";\n        htmlOutput += "Save";\n      htmlOutput += "</div>";\n    htmlOutput += "</div>";\n    return htmlOutput;\n  }\n\n  DrawingMenu.prototype.showDrawingTools = function() {\n\n    this.enableActiveTool();\n    this.redrawActiveTool();\n\n    for(var i = 0; i < this.drawingTools.length; i++) {\n      this.drawingTools[i].showHtml();\n    }\n\n    jQuery(\'.cf_action_list.ia_\'+this.id+\' .render_holes\').fadeIn();\n    jQuery(\'.cf_action_list.ia_\'+this.id+ \' .done_drawing\').fadeIn();\n\n    this.instance.undoRedo.redrawUndoRedoLinks();\n    jQuery(\'.cf_action_list.ia_\'+this.id+\' .cf_undo\').fadeIn();\n    jQuery(\'.cf_action_list.ia_\'+this.id+\' .cf_redo\').fadeIn();\n\n    jQuery(\'.cf_action_list.ia_\'+this.id+\' .cf_object_list\').fadeIn();\n    jQuery(\'.cf_action_list.ia_\'+this.id+\' .cf_path_list\').fadeIn();\n  }\n\n  DrawingMenu.prototype.disableDrawingTools = function() {\n    for(var i = 0; i < this.drawingTools.length; i++) {\n      this.drawingTools[i].hideHtml();\n    }\n    jQuery(\'.cf_action_list.ia_\'+this.id+\' .cf_redo\').hide();\n    jQuery(\'.cf_action_list.ia_\'+this.id+\' .cf_undo\').hide();\n    jQuery(\'.cf_action_list.ia_\'+this.id+\' .done_drawing\').hide();\n    jQuery(\'.edit_previous_object.ia_\'+this.id).hide();\n    jQuery(\'.cf_action_list.ia_\'+this.id+\' .cf_object_list\').hide();\n    this.disableActiveTool();\n  }\n\n  DrawingMenu.prototype.drawPathList = function() {\n    this.drawCurrentObjPathList();\n  }\n\n  DrawingMenu.prototype.drawCurrentObjPathList = function() {\n    var cp = this.instance.core.getCreatedPaths();\n    //var obj_index = this.instance.core.getActiveObjectIndex();\n    //var $objectDiv = jQuery(\'.object.ia_\'+this.id).attr("id",obj_index);\n    var pathList = jQuery(".cf_action_list.ia_"+this.id+" .cf_path_list");\n    pathList.html("");\n    if(cp.length > 0) {\n      for(var i = 0; i < cp.length; i++) {\n        this.instance.menu.appendToPathList(cp[i],i);\n      }\n    }\n    else {\n      pathList.append("<div class=\'cf_empty_path_list\'>0 Drawn</div>");\n    }\n  }\n\n  DrawingMenu.prototype.generatePLElementHTML = function(path, index) {\n    if(path.data.toolType) {\n      var currentToolType = this.instance.menu.getTool(path.data.toolType);\n      return currentToolType.toPathListHtml(path,index);\n    }\n  }\n\n  DrawingMenu.prototype.drawObjectList = function() {\n    var oList = this.instance.core.getObjectList();\n    // jQuery(".cf_object_list.ia_"+this.id).html(\n    // ""\n    // );\n\n    //for(var i = 0; i < oList.length; i++) {\n    //  this.instance.menu.appendToObjectList(oList[i],i);\n    //}\n  }\n\n  DrawingMenu.prototype.appendToObjectList = function(elem,index) {\n    var aoIndex = this.instance.core.getActiveObjectIndex();\n    var elem_name = elem.name;\n    var object_html;\n\n    if(index == aoIndex) {\n      object_html  =\n        "<div class=\'object ia_"+this.id+"\' id=\'"+index+"\' name=\'"+\n        elem_name+"\'></div>";\n    }\n    else {\n      object_html  =\n        "<div class=\'object ia_"+this.id+"\' id=\'"+index+"\' name=\'"+\n        elem_name+"\'></div>";\n    }\n\n    jQuery(".cf_action_list.ia_"+this.id+" .cf_object_list").append(object_html);\n\n    var pathList = "<div class=\'cf_path_list\'></div>";\n    var $objectDiv = jQuery(\'.object\').attr("id",index);\n    $objectDiv.append(pathList);\n  }\n\n  DrawingMenu.prototype.appendToPathList = function(elem,index) {\n    var pathList = jQuery(".cf_action_list.ia_"+this.id+" .cf_object_list .cf_path_list");\n    pathList.prepend(this.instance.menu.generatePLElementHTML(elem,index));\n  }\n\n  DrawingMenu.prototype.getToolFromHtml = function(html) {\n    var dmIndex = 0;\n    var tools = this.drawingTools;\n\n    for(var i = 0; i < tools.length; i++) {\n      jQuery(html).attr(\'class\').split(\' \').each (function(c) {\n        if(c == \'dm_\'+i) {\n          dmIndex = i;\n          return tools[dmIndex];\n        }\n      });\n    }\n    return tools[dmIndex];\n  }\n\n  //skeleton of a DrawingTool\n  //create a constant identifier in DrawingToolConstants\n  //create link between identifier and new instance of object\n  //in DrawingToolConstantToObject\n  function DrawingTool(instanceID,instance) {\n    this.tool = new paper.Tool();\n    this.instance = instance;\n    this.id = instanceID;\n\n    var toolType = DrawingToolConstants.DEFAULT\n\n    this.tool.onMouseDown = function(event) {\n    }\n\n    this.tool.onMouseDrag = function(event) {\n    }\n\n    this.tool.onMouseMove = function(event) {\n    }\n\n    this.tool.onMouseUp = function(event) {\n    }\n\n    this.toHtml = function() {\n    }\n\n    this.toPathListHtml = function(path) {\n    }\n\n    this.showHtml = function() {\n    }\n\n    this.hideHtml = function() {\n    }\n\n    this.previewPaths = function(paths) {\n    }\n\n    this.getToolType = function() {\n      return toolType;\n    }\n  }\n\n  DrawingTool.prototype.saveColorPath = function(path) {\n    path.fillColor = new paper.Color(0.06,0.69,0.36,0.8);\n  }\n\n  DrawingTool.prototype.removePath = function(path) {\n    path.remove();\n  }\n\n  DrawingTool.prototype.goldColorPath = function(path) {\n    path.fillColor = new paper.Color(1,0.5,0,0.7);\n  }\n\n  DrawingTool.prototype.highlightColorPath = function(path) {\n    path.fillColor = new paper.Color(0,0,0,0.3);\n  }\n\n  DrawingTool.prototype.colorPath = function(path) {\n    path.fillColor = new paper.Color(1,0,0,0.2);\n  }\n\n  DrawingTool.prototype.removePathFromPathList = function(path_to_remove) {\n    var cPaths = this.instance.core.getCreatedPaths();\n    var temp = [];\n    cPaths.each(function(value,index) {\n      if(value.id == path_to_remove.id) {\n      }\n      else {\n        temp.push(value);\n      }\n    });\n    return temp;\n  }\n\n  function LineDrawingTool(instanceID, instance) {\n    this.tool = new paper.Tool();\n    this.instance = instance;\n    this.id = instanceID;\n\n    var toolType = DrawingToolConstants.LINE;\n    var privateSelf = this;\n    var path = null;\n    var movePath = null;\n    var strokeType = null;\n    var segment = null;\n    var firstCircle = null;\n    var secondCircle = null;\n    var hitOptions = {\n        segments: true,\n        stroke: true,\n        fill: true,\n        tolerance: 5\n    };\n\n    this.getToolType = function() {\n      return toolType;\n    }\n\n    this.tool.onMouseDown = function(event) {\n      var inst = privateSelf.instance;\n      secondCircle = null;\n      path = null;\n      firstCircle = new paper.Path.Circle({\n          center: [event.point.x,event.point.y],\n          fillColor: \'#f6771a\',\n          radius: privateSelf.Constants.POINT_RADIUS\n      });\n      firstCircle.data.lineType = privateSelf.Constants.LINE_END_PATH;\n      paper.project.view.draw();\n    }\n\n    this.tool.onMouseMove = function(event) {\n    }\n\n    this.tool.onMouseDrag = function(event) {\n      if( path != null ) {\n        path.remove();\n      }\n      if( secondCircle != null ) {\n        secondCircle.remove();\n      }\n      path = new paper.Path({\n        segments: [[firstCircle.segments[1].point.x, firstCircle.segments[0].point.y],\n                  [event.point.x,event.point.y]],\n        strokeColor: \'#f6771a\',\n        closed: false\n      });\n      path.data.lineType = privateSelf.Constants.LINE_MAIN_PATH;\n      secondCircle = new paper.Path.Circle({\n        center: [event.point.x,event.point.y],\n        fillColor: \'#f6771a\',\n        radius: privateSelf.Constants.POINT_RADIUS\n      });\n      secondCircle.data.lineType = privateSelf.Constants.LINE_END_PATH;\n    }\n\n\n\n    this.tool.onMouseUp = function(event) {\n      var inst = privateSelf.instance;\n      if(firstCircle != null && secondCircle != null && path != null) {\n        firstCircle.data.lineID = path.id;\n        secondCircle.data.lineID = path.id;\n        path.data.mainID = path.id;\n\n        inst.core.addNewPath(firstCircle,toolType);\n        inst.core.addNewPath(secondCircle,toolType);\n        inst.core.addNewPath(path,toolType);\n        inst.undoRedo.saveCPState();\n      }\n      else {\n        if(firstCircle != null) { firstCircle.remove(); }\n        if(secondCircle != null) { secondCircle.remove(); }\n        if(path != null) { path.remove(); }\n      }\n    }\n  }\n\n  LineDrawingTool.prototype = new DrawingTool();\n  LineDrawingTool.prototype.constructor = LineDrawingTool;\n\n  LineDrawingTool.prototype.Constants = {\n    POINT_RADIUS: 3,\n    LINE_END_PATH: "line end point",\n    LINE_MAIN_PATH: "line main path",\n  }\n\n  LineDrawingTool.prototype.highlightColorPath = function(path) {\n    var paths = this.instance.core.getCreatedPaths();\n    var endPaths = this.findEndPaths(path,paths);\n    if (endPaths.length > 0) {\n      endPaths[0].fillColor = new paper.Color(0,0,0,0.3);\n      endPaths[1].fillColor = new paper.Color(0,0,0,0.3);\n    }\n    path.strokeColor = new paper.Color(0,0,0,0.3);\n  }\n\n  LineDrawingTool.prototype.backFromHighlightColorPath = function(path) {\n    var paths = this.instance.core.getCreatedPaths();\n    var endPaths = this.findEndPaths(path,paths);\n    if (endPaths.length > 0) {\n      endPaths[0].fillColor = \'#f6771a\';\n      endPaths[1].fillColor = \'#f6771a\';\n    }\n    path.strokeColor = \'#f6771a\';\n  }\n\n  LineDrawingTool.prototype.removePathFromPathList = function(path_to_remove) {\n    var cPaths = this.instance.core.getCreatedPaths();\n    var temp = [];\n    var lineID = path_to_remove.data.mainID;\n    cPaths.each(function(value,index) {\n      if(value.id == path_to_remove.id ||\n          (value.data.lineID && value.data.lineID == lineID)) {\n      }\n      else {\n        temp.push(value);\n      }\n    });\n    return temp;\n  }\n\n  LineDrawingTool.prototype.findEndPaths = function(path,paths) {\n    var endPaths = []\n    var lineID = path.data.mainID;\n\n    for(var i = 0; i < paths.length; i++) {\n      if(paths[i].data.lineID && paths[i].data.lineID == lineID) {\n        if(endPaths.length == 0) {\n          endPaths.push(paths[i]);\n        }\n        else{\n          endPaths.push(paths[i]);\n          break;\n        }\n      }\n    }\n    return endPaths;\n  }\n\n  LineDrawingTool.prototype.removePath = function(path_to_remove) {\n    var paths = this.instance.core.getCreatedPaths();\n    var endPaths = this.findEndPaths(path_to_remove,paths);\n    if (endPaths.length > 0) {\n      endPaths[1].remove();\n      endPaths[0].remove();\n    }\n    path_to_remove.remove();\n  }\n\n  LineDrawingTool.prototype.colorPath = function(path) {\n    if( path.data.lineType == this.Constants.LINE_MAIN_PATH) {\n      path.strokeColor = \'#f6771a\';\n    }\n    else {\n      path.fillColor = \'#f6771a\';\n    }\n  }\n\n  LineDrawingTool.prototype.goldColorPath = function(path) {\n    path.strokeColor = new paper.Color(1,0.5,0,0.7);\n  }\n\n  LineDrawingTool.prototype.saveColorPath = function(path) {\n    path.strokeColor = new paper.Color(0.06,0.69,0.36,0.8);\n  }\n\n  LineDrawingTool.prototype.toHtml = function() {\n    var htmlOutput = "";\n    htmlOutput += "<div class=\'line_container\'>";\n      htmlOutput += "<div class=\'tool_title_container\'>";\n        htmlOutput += "<div class=\'tool_title_text large_med_t_text\'>";\n          htmlOutput += "Line";\n        htmlOutput += "</div>";\n      htmlOutput += "</div>";\n      htmlOutput += "<div class=\'tool_content_container\'>";\n        htmlOutput += "<div class=\'line_radius_container\'>";\n          htmlOutput += "<div class=\'line_radius_1\'>";\n          htmlOutput += "</div>";\n        htmlOutput += "</div>";\n        htmlOutput += "<div class=\'line_line_container\'>";\n          htmlOutput += "<div class=\'line_line\'>";\n          htmlOutput += "</div>";\n        htmlOutput += "</div>";\n        htmlOutput += "<div class=\'line_radius_container\'>";\n          htmlOutput += "<div class=\'line_radius_2\'>";\n          htmlOutput += "</div>";\n        htmlOutput += "</div>";\n      htmlOutput += "</div>";\n    htmlOutput += "</div>";\n    return htmlOutput;\n  }\n\n  LineDrawingTool.prototype.toPathListHtml = function(path,index) {\n    if(path.data.lineType == this.Constants.LINE_MAIN_PATH) {\n      var highlightPath = "<div class=\'highlight_path line_path ia_"+\n        this.id +"\' id=\'" + index + "\'> Line</div>";\n\n      var deletePath = "<div class=\'delete_path ia_"+\n        this.id+"\' id=\'" + index +\n          "\'>x</div>";\n      return "<div class=\'single_path ia_"+this.id+"\'>" +\n        highlightPath + deletePath + "</div>";\n    }\n    return "";\n  }\n\n  LineDrawingTool.prototype.showHtml = function() {\n    jQuery(\'.ia_line_tool.ia_\'+this.id).fadeIn();\n    jQuery(\'.line_container.ia_\'+this.id).fadeIn();\n  }\n\n  LineDrawingTool.prototype.hideHtml = function() {\n    jQuery(\'.ia_line_tool.ia_\'+this.id).hide();\n    jQuery(\'.line_container.ia_\'+this.id).hide();\n  }\n\n  LineDrawingTool.prototype.previewPaths = function(paths) {\n    var newPaths = [];\n    var j = 0;\n\n    for(var i = 0; i < paths.length; i++) {\n      if( paths[i].data.lineType == this.Constants.LINE_MAIN_PATH) {\n        newPaths[j] = new paper.Path( {\n          segments: paths[i].segments,\n          closed: false\n        })\n        newPaths[j].data = paths[i].data;\n        if(newPaths[j].data.stateType == this.instance.core.Constants.REGULAR_STATE_TYPE) {\n          this.saveColorPath(newPaths[j]);\n        }\n        else {\n          this.instance.core.colorPath(newPaths[j]);\n        }\n        newPaths[j].clockwise = true;\n        j++;\n      }\n    }\n\n    for(var i = 0; i < paths.length; i++) {\n\n      if( paths[i].data.lineType == this.Constants.LINE_MAIN_PATH) {\n        if( this.findEndPaths(paths[i],this.instance.core.getCreatedPaths()).length == 2) {\n          this.instance.core.deletePath(paths[i]);\n        }\n        else {\n          paths[i].remove();\n        }\n      }\n    }\n\n    return newPaths;\n  }\n\n  function DotDrawingTool(instanceID, instance) {\n    this.tool = new paper.Tool();\n    this.instance = instance;\n    this.id = instanceID;\n\n    var toolType = DrawingToolConstants.DOT;\n    var privateSelf = this;\n\n    var radius = this.Constants.DEFAULT_RADIUS;\n    var path = null;\n\n    this.getRadius = function() {\n      return radius;\n    }\n\n    this.getToolType = function() {\n      return toolType;\n    }\n\n    this.tool.onMouseDown = function(event) {\n      path = new paper.Path.Circle({\n          center: event.point,\n          radius: radius,\n          fillColor: new paper.Color(1,0,1),\n          strokeColor: new paper.Color(1,1,1),\n      });\n      path.data.radius = radius;\n      paper.project.view.draw();\n    }\n\n    this.tool.onMouseMove = function(event) {\n    }\n\n    this.tool.onMouseDrag = function(event) {\n    }\n\n    this.tool.onMouseUp = function(event) {\n      var inst = privateSelf.instance;\n      inst.core.addNewPath(path,toolType);\n      inst.undoRedo.saveCPState();\n    }\n  }\n\n  DotDrawingTool.prototype = new DrawingTool();\n  DotDrawingTool.prototype.constructor = DotDrawingTool;\n\n  DotDrawingTool.prototype.genCenterFromPath = function(path) {\n    var xCenter = 0;\n    var yCenter = 0;\n    //find repeating x-coordinate for x-center, y-center must be other\n    if(path.segments[1].point.x == path.segments[3].point.x) {\n      xCenter = path.segments[1].point.x;\n      yCenter = path.segments[0].point.y;\n    }\n    else {\n      xCenter = path.segments[0].point.x;\n      yCenter = path.segments[1].point.y;\n    }\n    return new paper.Point(xCenter, yCenter)\n  }\n\n  DotDrawingTool.prototype.Constants = {\n    DEFAULT_RADIUS: 3\n  }\n\n  DotDrawingTool.prototype.toHtml = function() {\n    var htmlOutput = "";\n    htmlOutput += "<div class=\'dot_container\'>";\n      htmlOutput += "<div class=\'tool_title_container\'>";\n        htmlOutput += "<div class=\'tool_title_text large_short_t_text\'>";\n          htmlOutput += "Dot";\n        htmlOutput += "</div>";\n      htmlOutput += "</div>";\n      htmlOutput += "<div class=\'tool_content_container\'>";\n        htmlOutput += "<div class=\'dot_radius d_on\' ></div>";\n      htmlOutput += "</div>";\n    htmlOutput += "</div>";\n    return htmlOutput;\n  }\n\n  DotDrawingTool.prototype.toPathListHtml = function(path,index) {\n    var highlightPath = "<div class=\'highlight_path dot_path ia_"+\n      this.id +"\' id=\'" + index + "\'> D " + index + "</div>";\n\n    var deletePath = "<div class=\'delete_path ia_"+\n      this.id+"\' id=\'" + index +\n        "\'>x</div>";\n\n    return "<div class=\'single_path ia_"+this.id+"\'>" +\n      highlightPath + deletePath + "</div>";\n  }\n\n  DotDrawingTool.prototype.showHtml = function() {\n    var radius = this.getRadius();\n    if( radius == this.Constants.DEFAULT_RADIUS) {\n      jQuery(\'.dot_radius.ia_\'+this.id).addClass(\'d_on\');\n    }\n\n    jQuery(\'.ia_dot_tool.ia_\'+this.id).fadeIn();\n    jQuery(\'.dot_container.ia_\'+this.id).fadeIn();\n    jQuery(\'.dot_radius.ia_\'+this.id).fadeIn();\n  }\n\n  DotDrawingTool.prototype.hideHtml = function() {\n    jQuery(\'.ia_dot_tool.ia_\'+this.id).hide();\n    jQuery(\'.dot_container.ia_\'+this.id).hide();\n    jQuery(\'.dot_radius.ia_\'+this.id).hide();\n  }\n\n  DotDrawingTool.prototype.previewPaths = function(paths) {\n    var newPaths = [];\n\n    for(var i = 0; i < paths.length; i++) {\n      newPaths[i] = new paper.Path.Circle( {\n        center: this.genCenterFromPath(paths[i]),\n        radius: paths[i].data.radius\n      })\n      newPaths[i].data = paths[i].data;\n      if(newPaths[i].data.stateType == this.instance.core.Constants.REGULAR_STATE_TYPE) {\n        this.saveColorPath(newPaths[i]);\n      }\n      else {\n        this.instance.core.colorPath(newPaths[i]);\n      }\n      newPaths[i].clockwise = true;\n    }\n\n    for(var i = 0; i < paths.length; i++) {\n      this.instance.core.deletePath(paths[i]);\n    }\n\n    return newPaths;\n  }\n\n  DotDrawingTool.prototype.colorPath = function(path) {\n    path.fillColor = new paper.Color(1,0,1);\n    path.strokeColor = new paper.Color(1,1,1);\n  }\n\n  DotDrawingTool.prototype.backFromHighlightColorPath = function(path) {\n    path.fillColor = new paper.Color(1,0,1,0.5);\n  }\n\n  DotDrawingTool.prototype.highlightColorPath = function(path) {\n    path.fillColor = new paper.Color(0,0,0,0.3);\n  }\n\n  DotDrawingTool.prototype.saveColorPath = function(path) {\n    path.fillColor = new paper.Color(0.06,0.69,0.36,0.8);\n  }\n\n  function BrushDrawingTool(instanceID,instance) {\n    this.tool = new paper.Tool();\n    this.instance = instance;\n    this.id = instanceID;\n\n    var toolType = DrawingToolConstants.BRUSH\n    var privateSelf = this;\n\n    var paths = [];\n    var path = null;\n    var lastPath = null;\n    var radius = this.Constants.LARGE_RADIUS;\n    var cursor = null;\n\n    var calcMaxSpread = function() {\n      return radius * 2 * 0.10;\n    }\n\n    var spread = calcMaxSpread();\n\n    this.getToolType = function() {\n      return toolType;\n    }\n\n    this.getRadius = function() {\n      return radius;\n    }\n\n    this.setSmallRadius = function() {\n      radius = this.Constants.SMALL_RADIUS;\n      spread = calcMaxSpread();\n    }\n\n    this.setMediumRadius = function() {\n      radius = this.Constants.MEDIUM_RADIUS;\n      spread = calcMaxSpread();\n    }\n\n    this.setMediumLargeRadius = function() {\n      radius = this.Constants.MEDIUM_LARGE_RADIUS;\n      spread = calcMaxSpread();\n    }\n\n    this.setLargeRadius = function() {\n      radius = this.Constants.LARGE_RADIUS;\n      spread = calcMaxSpread();\n    }\n\n    this.tool.onMouseDown = function(event) {\n      paths = []\n      path = new paper.Path({\n          segments: [event.point],\n          strokeWidth: radius*2,\n          strokeCap: \'round\',\n            clockwise:true,\n            strokeColor:new paper.Color(0.3,1,1,0.5),\n          strokeJoin: \'round\'\n      });\n      path.data.radius = radius;\n      lastPath = path;\n      paper.project.view.draw();\n    }\n\n    this.tool.onMouseDrag = function(event) {\n      path.add(event.point);\n      if(cursor != null) {\n        cursor.remove();\n      }\n      cursor = new paper.Path.Circle({\n        center: event.point,\n        radius: radius,\n        fillColor:new paper.Color(0.3,1,1,0.3)\n      });\n    }\n\n    this.tool.onMouseMove = function(event) {\n      if(cursor != null) {\n        cursor.remove();\n      }\n      cursor = new paper.Path.Circle({\n        center: event.point,\n        radius: radius,\n        fillColor:new paper.Color(0.3,1,1,0.3)\n      });\n    }\n\n    this.tool.onMouseUp = function(event) {\n      var inst = privateSelf.instance;\n      cursor.remove();\n      if(path.segments.length > 1) {\n        path.closed = false;\n        path.simplify();\n        path.flatten(20);\n        inst.core.addNewPath(path,toolType);\n        inst.undoRedo.saveCPState();\n      }\n    }\n\n  }\n\n  BrushDrawingTool.prototype = new DrawingTool();\n  BrushDrawingTool.prototype.constructer = BrushDrawingTool;\n\n  BrushDrawingTool.prototype.Constants = {\n    SMALL_RADIUS: 5,\n    MEDIUM_RADIUS: 10,\n    MEDIUM_LARGE_RADIUS: 15,\n    LARGE_RADIUS: 20\n  }\n\n\n  BrushDrawingTool.prototype.toHtml = function() {\n    var htmlOutput = "";\n    htmlOutput += "<div class=\'brush_container\'>";\n      htmlOutput += "<div class=\'tool_title_container\'>";\n        htmlOutput += "<div class=\'tool_title_text large_long_t_text\'>";\n          htmlOutput += "Brush";\n        htmlOutput += "</div>";\n      htmlOutput += "</div>";\n      htmlOutput += "<div class=\'tool_content_container\'>";\n        htmlOutput += "<div class=\'small_radius b_off\'></div>"\n        htmlOutput += "<div class=\'medium_radius b_on\'></div>";\n        htmlOutput += "<div class=\'medium_large_radius b_off\'></div>";\n        htmlOutput += "<div class=\'large_radius b_off\'></div>";\n      htmlOutput += "</div>";\n    htmlOutput += "</div>";\n    return htmlOutput;\n  }\n\n  BrushDrawingTool.prototype.toPathListHtml = function(path,index) {\n    var highlightPath = "<div class=\'highlight_path brush_path ia_"+\n      this.id +"\' id=\'" + index + "\'> B " + index + "</div>";\n\n    var deletePath = "<div class=\'delete_path ia_"+\n      this.id+"\' id=\'" + index +\n        "\'>x</div>";\n\n    return "<div class=\'single_path ia_"+this.id+"\'>" +\n      highlightPath + deletePath + "</div>";\n  }\n\n  BrushDrawingTool.prototype.showHtml = function() {\n    var radius = this.getRadius();\n    var id = this.id;\n    if( radius == this.Constants.SMALL_RADIUS) {\n      jQuery(\'.medium_large_radius.ia_\'+id).removeClass(\'b_on\').addClass(\'b_off\');\n      jQuery(\'.large_radius.ia_\'+id).removeClass(\'b_on\').addClass(\'b_off\');\n      jQuery(\'.medium_radius.ia_\'+id).removeClass(\'b_on\').addClass(\'b_off\');\n      jQuery(\'.small_radius.ia_\'+id).removeClass(\'b_off\').addClass(\'b_on\');\n    }\n    else if( radius == this.Constants.MEDIUM_RADIUS) {\n      jQuery(\'.small_radius.ia_\'+id).removeClass(\'b_on\').addClass(\'b_off\');\n      jQuery(\'.medium_large_radius.ia_\'+id).removeClass(\'b_on\').addClass(\'b_off\');\n      jQuery(\'.large_radius.ia_\'+id).removeClass(\'b_on\').addClass(\'b_off\');\n      jQuery(\'.medium_radius.ia_\'+id).removeClass(\'b_off\').addClass(\'b_on\');\n    }\n    else if( radius == this.Constants.MEDIUM_LARGE_RADIUS) {\n      jQuery(\'.small_radius.ia_\'+id).removeClass(\'b_on\').addClass(\'b_off\');\n      jQuery(\'.large_radius.ia_\'+id).removeClass(\'b_on\').addClass(\'b_off\');\n      jQuery(\'.medium_radius.ia_\'+id).removeClass(\'b_on\').addClass(\'b_off\');\n      jQuery(\'.medium_large_radius.ia_\'+id).removeClass(\'b_off\').addClass(\'b_on\');\n    }\n    else if( radius == this.Constants.LARGE_RADIUS) {\n      jQuery(\'.small_radius.ia_\'+id).removeClass(\'b_on\').addClass(\'b_off\');\n      jQuery(\'.medium_radius.ia_\'+id).removeClass(\'b_on\').addClass(\'b_off\');\n      jQuery(\'.medium_large_radius.ia_\'+id).removeClass(\'b_on\').addClass(\'b_off\');\n      jQuery(\'.large_radius.ia_\'+id).removeClass(\'b_off\').addClass(\'b_on\');\n    }\n\n    jQuery(\'.ia_brush_tool.ia_\'+id).fadeIn();\n    jQuery(\'.brush_container.ia_\'+id).fadeIn();\n    jQuery(\'.medium_radius.ia_\'+id).fadeIn();\n    jQuery(\'.medium_large_radius.ia_\'+id).fadeIn();\n    jQuery(\'.large_radius.ia_\'+id).fadeIn();\n    jQuery(\'.small_radius.ia_\'+id).fadeIn();\n  }\n\n  BrushDrawingTool.prototype.hideHtml = function() {\n    jQuery(\'.ia_brush_tool.ia_\'+this.id).hide();\n    jQuery(\'.brush_container.ia_\'+this.id).hide();\n    jQuery(\'.medium_radius.ia_\'+this.id).hide();\n    jQuery(\'.medium_large_radius.ia_\'+this.id).hide();\n    jQuery(\'.large_radius.ia_\'+this.id).hide();\n    jQuery(\'.small_radius.ia_\'+this.id).hide();\n  }\n\n  BrushDrawingTool.prototype.previewPaths = function(paths) {\n    var newPaths = [];\n\n    for(var i = 0; i < paths.length; i++) {\n      newPaths[i] = new paper.Path(paths[i].segments);\n      newPaths[i].data = paths[i].data;\n      if(newPaths[i].data.stateType == this.instance.core.Constants.REGULAR_STATE_TYPE) {\n        this.saveColorPath(newPaths[i]);\n      }\n      else {\n        this.instance.core.colorPath(newPaths[i]);\n      }\n      newPaths[i].clockwise = true;\n    }\n\n    for(var i = 0; i < paths.length; i++) {\n      this.instance.core.deletePath(paths[i]);\n    }\n\n    return newPaths;\n  }\n\n  BrushDrawingTool.prototype.colorPath = function(path) {\n    path.strokeColor = new paper.Color(0.3,1,1,0.5);\n    path.strokeCap = \'round\';\n    path.strokeWidth = path.data.radius * 2;\n    path.strokeJoin = \'round\';\n  }\n\n  BrushDrawingTool.prototype.goldColorPath = function(path) {\n    path.strokeColor = new paper.Color(1,0.5,0,0.7);\n    path.strokeWidth = path.data.radius*2;\n    path.strokeCap = \'round\';\n    path.strokeJoin = \'round\';\n  }\n\n  BrushDrawingTool.prototype.backFromHighlightColorPath = function(path) {\n    path.strokeColor = new paper.Color(0.3,1,1,0.5);\n    path.strokeCap = \'round\';\n    path.strokeWidth = path.data.radius * 2;\n    path.strokeJoin = \'round\';\n  }\n\n  BrushDrawingTool.prototype.highlightColorPath = function(path) {\n    path.strokeColor = new paper.Color(0,0,0,0.3);\n    path.strokeCap = \'round\';\n    path.strokeWidth = path.data.radius * 2;\n    path.strokeJoin = \'round\';\n  }\n\n  BrushDrawingTool.prototype.saveColorPath = function(path) {\n    path.strokeColor = new paper.Color(0.06,0.69,0.36,0.8);\n    path.strokeCap = \'round\';\n    path.strokeWidth = path.data.radius * 2;\n    path.strokeJoin = \'round\';\n  }\n\n  function PolygonDrawingTool(instanceID,instance) {\n    this.tool = new paper.Tool();\n    this.instance = instance;\n    this.id = instanceID;\n    var id = instanceID;\n    var privateSelf = this;\n\n    var toolType = DrawingToolConstants.POLYGON\n    var mode = this.Constants.FREE_DRAW_DRAWING_MODE;\n    var type = this.Constants.POLYGON_DRAWING_TYPE;\n    var prevMode = mode;\n\n    var path = null;\n    var movePath = null;\n    var strokeType = null;\n    var segment = null;\n    var hitOptions = {\n        segments: true,\n        stroke: true,\n        fill: true,\n        tolerance: 5\n    };\n\n    this.getMode = function() {\n      return mode;\n    }\n\n    this.getType = function() {\n      return type;\n    }\n\n    this.getToolType = function() {\n      return toolType;\n    }\n\n    this.setFreeDrawMode = function() {\n      mode = this.Constants.FREE_DRAW_DRAWING_MODE;\n    }\n\n    this.setSelectionMode = function() {\n      mode = this.Constants.SELECTION_DRAWING_MODE;\n    }\n\n    this.setNoDrawingMode = function() {\n      mode = this.Constants.NO_DRAWING_MODE;\n    }\n\n    this.setModeFromPrevMode = function() {\n      mode = prevMode;\n    }\n\n    this.setPolygonDrawingType = function () {\n      type = this.Constants.POLYGON_DRAWING_TYPE;\n    }\n\n    this.setHoleDrawingType = function() {\n      type = this.Constants.HOLE_DRAWING_TYPE;\n    }\n\n    this.setPrevMode = function() {\n      prevMode = mode;\n    }\n\n    this.tool.onMouseUp = function(event) {\n      var inst = privateSelf.instance;\n      if( mode == privateSelf.Constants.FREE_DRAW_DRAWING_MODE ) {\n        var segmentCount = path.segments.length;\n\n        path.simplify();\n        path.flatten(20);\n\n        // Select the path, so we can see its segments:\n        path.fullySelected = true;\n        path.closed = true;\n        path.clockwise = true;\n        path.data.saved = false;\n\n        if(type == privateSelf.Constants.POLYGON_DRAWING_TYPE) {\n          path.data.drawing_type = privateSelf.Constants.POLYGON_DRAWING_TYPE;\n        }\n        else {\n          path.data.drawing_type = privateSelf.Constants.HOLE_DRAWING_TYPE;\n        }\n\n        if (path.area != 0) {\n          inst.core.addNewPath(path,toolType);\n          inst.undoRedo.saveCPState();\n        }\n      }\n      else if(strokeType = privateSelf.Constants.SELECTION_FILL_MOVEMENT) {\n          inst.undoRedo.saveCPState();\n          strokeType = null;\n      }\n      else if(strokeType = privateSelf.Constants.SELECTION_VERTEX_MOVEMENT) {\n          inst.undoRedo.saveCPState();\n          strokeType = null;\n      }\n      else if(strokeType = privateSelf.Constants.SELECTION_VERTEX_CREATION) {\n          inst.undoRedo.saveCPState();\n          strokeType = null;\n      }\n    }\n\n    this.tool.onMouseDown = function(event) {\n      var inst = privateSelf.instance;\n      if( mode == privateSelf.Constants.SELECTION_DRAWING_MODE ){\n        segment = path = null;\n        var hitResult = paper.project.hitTest(event.point, hitOptions);\n        if (!hitResult) {\n            return;\n        }\n\n        if (event.modifiers.shift ) {\n            return;\n            if (hitResult.type == \'segment\') {\n                hitResult.segment.remove();\n            };\n            return;\n        }\n\n        if (hitResult ) {\n            path = hitResult.item;\n            if (hitResult.type == \'segment\' && path.parent == paper.project.activeLayer &&\n                  path.data.toolType == DrawingToolConstants.POLYGON) {\n\n                strokeType = privateSelf.Constants.SELECTION_VERTEX_MOVEMENT;\n                segment = hitResult.segment;\n            } else if (hitResult.type == \'stroke\' && path.parent == paper.project.activeLayer &&\n                path.data.toolType == DrawingToolConstants.POLYGON) {\n\n                strokeType = privateSelf.Constants.SELECTION_VERTEX_CREATION;\n                var location = hitResult.location;\n                segment = path.insert(location.index + 1, event.point);\n                //path.smooth();\n            }\n\n        }\n        movePath = hitResult.type == \'fill\';\n        if (movePath && path && path.parent == paper.project.activeLayer &&\n          path.data.toolType == DrawingToolConstants.POLYGON) {\n            paper.project.activeLayer.addChild(hitResult.item);\n          strokeType = privateSelf.Constants.SELECTION_FILL_MOVEMENT;\n        }\n      }\n      else {\n\n        // Create a new path and set its stroke color to black:\n        if( mode == privateSelf.Constants.FREE_DRAW_DRAWING_MODE ) {\n          path = new paper.Path({\n              segments: [event.point],\n              // Select the path, so we can see its segment points:\n              fullySelected: true\n          });\n          paper.project.view.draw();\n        }\n      }\n    }\n\n    this.tool.onMouseDrag = function(event) {\n      var inst = privateSelf.instance;\n      if( mode == privateSelf.Constants.SELECTION_DRAWING_MODE && path.parent ==\n        paper.project.activeLayer ) {\n        if (segment) {\n          segment.point = event.point;\n          inst.menu.drawPathList();\n        }\n\n        if (movePath && path.parent == paper.project.activeLayer) {\n          path.position = path.position.add([event.delta.x,event.delta.y]);\n        }\n      }\n      else {\n        if(mode == privateSelf.Constants.FREE_DRAW_DRAWING_MODE ) {\n          path.add(event.point);\n        }\n      }\n    }\n\n    this.tool.onMouseMove = function(event) {\n      paper.project.activeLayer.selected = false;\n      if (event.item && event.item.fillColor != null &&\n        event.item.parent == paper.project.activeLayer) {\n        event.item.selected = true;\n      }\n    }\n  }\n\n  PolygonDrawingTool.prototype = new DrawingTool();\n  PolygonDrawingTool.prototype.constructor = PolygonDrawingTool;\n\n  PolygonDrawingTool.prototype.Constants = {\n    FREE_DRAW_DRAWING_MODE: "free draw",\n    POLYGON_DRAWING_TYPE: "polygon drawing type",\n    NO_DRAWING_MODE: "no drawing mode",\n    HOLE_DRAWING_TYPE: "hole drawing type",\n    SELECTION_DRAWING_MODE: "selection mode",\n    SELECTION_VERTEX_MOVEMENT: "selection vertex movement",\n    SELECTION_VERTEX_CREATION: "selection vertex creation",\n    SELECTION_FILL_MOVEMENT: "selection fill movement"\n  }\n\n  PolygonDrawingTool.prototype.colorPath = function(path) {\n    if( path.data.drawing_type == this.Constants.HOLE_DRAWING_TYPE) {\n      path.fillColor = new paper.Color(1,0.8,0,0.2);\n    }\n    else {\n      path.fillColor = new paper.Color(1,0,0,0.2);\n    }\n  }\n\n  PolygonDrawingTool.prototype.backFromHighlightColorPath = function(path) {\n    if( path.data.drawing_type == this.Constants.HOLE_DRAWING_TYPE) {\n      path.fillColor = new paper.Color(1,0.8,0,0.2);\n    }\n    else {\n      path.fillColor = new paper.Color(1,0,0,0.2);\n    }\n  }\n\n  PolygonDrawingTool.prototype.toHtml = function() {\n    htmlOutput = "";\n    htmlOutput = "<div class=\'polygon_container\'>";\n      htmlOutput +="<div class=\'tool_title_container\'>";\n        htmlOutput += "<div class=\'tool_title_text medium_long_t_text\'>";\n          htmlOutput += "Polygon";\n        htmlOutput += "</div>";\n      htmlOutput += "</div>";\n      htmlOutput += "<div class=\'tool_content_container\'>";\n        htmlOutput += "<div class=\'free_draw_on\'>";\n          htmlOutput += "<div class=\'draw_polygon\'>";\n            htmlOutput += "<div class=\'poly_text\'>";\n              htmlOutput += "+";\n            htmlOutput += "</div>";\n          htmlOutput += "</div>";\n          htmlOutput += "<div class=\'draw_hole off\'>";\n            htmlOutput += "<div class=\'hole_text\'>";\n              htmlOutput += "-";\n            htmlOutput += "</div>";\n          htmlOutput += "</div>";\n        htmlOutput += "</div>";\n        htmlOutput += "<div class=\'free_draw_off\'>";\n          htmlOutput += "<div class=\'select_text\'>";\n            htmlOutput += "edit/move";\n          htmlOutput += "</div>";\n        htmlOutput += "</div>";\n      htmlOutput += "</div>";\n    htmlOutput += "</div>";\n    return htmlOutput;\n  }\n\n  PolygonDrawingTool.prototype.showHtml = function() {\n    this.setModeFromPrevMode();\n    if(this.getMode() == this.Constants.FREE_DRAW_DRAWING_MODE) {\n      jQuery( ".free_draw_off.ia_"+this.id ).addClass("off");\n      jQuery( ".free_draw_on.ia_"+this.id ).removeClass("off");\n    }\n    else if(this.getMode() == this.Constants.SELECTION_DRAWING_MODE) {\n      jQuery( ".free_draw_on.ia_"+this.id ).addClass("off");\n      jQuery( ".free_draw_off.ia_"+this.id ).removeClass("off");\n    }\n    else {\n    }\n\n    if( this.getType() == this.Constants.POLYGON_DRAWING_TYPE) {\n      jQuery( ".draw_hole.ia_"+this.id).addClass("off");\n      jQuery( ".draw_polygon.ia_"+this.id ).removeClass("off");\n    }\n    else if( this.getType() == this.Constants.HOLE_DRAWING_TYPE) {\n      jQuery( ".draw_polygon.ia_"+this.id).addClass("off");\n      jQuery( ".draw_hole.ia_"+this.id ).removeClass("off");\n    }\n    jQuery(\'.polygon_container.ia_\'+this.id).fadeIn();\n    jQuery(\'.draw_hole.ia_\'+this.id).fadeIn();\n    jQuery(\'.draw_polygon.ia_\'+this.id).fadeIn();\n  }\n\n  PolygonDrawingTool.prototype.hideHtml = function() {\n    this.setPrevMode();\n    this.setNoDrawingMode();\n    jQuery(\'.polygon_container.ia_\'+this.id).hide();\n    jQuery(\'.draw_polygon.ia_\'+this.id).hide();\n    jQuery(\'.draw_hole.ia_\'+this.id).hide();\n  }\n\n  PolygonDrawingTool.prototype.toPathListHtml = function(path,index) {\n    if(path.data.drawing_type == this.Constants.POLYGON_DRAWING_TYPE) {\n      //polygon\n      var highlightPath = "<div class=\'highlight_path polygon_path ia_"+\n        this.id +"\' id=\'" + index + "\'> P " +\n          index + "</div>";\n\n      var deletePath = "<div class=\'delete_path polygon_path ia_"+\n        this.id+"\' id=\'" + index +\n          "\'>x</div>";\n\n      return "<div class=\'single_path ia_"+this.id+"\'>" +\n        highlightPath + deletePath + "</div>";\n    }\n    else if(path.data.drawing_type == this.Constants.HOLE_DRAWING_TYPE) {\n      //hole\n      var highlightPath = "<div class=\'highlight_path hole_path ia_"+\n        this.id+"\' id=\'" + index + "\'> H " +\n          index + "</div>";\n      var deletePath = "<div class=\'delete_path hole_path ia_"+\n        this.id+"\' id=\'" + index +\n        "\'>x</div>";\n\n      return "<div class=\'single_path ia_" +\n        this.id + "\'>" + highlightPath + deletePath + "</div>";\n    }\n  }\n\n  PolygonDrawingTool.prototype.previewPaths = function(paths) {\n    var inst = this.instance;\n    var correctDrawingTool = inst.menu.getTool(DrawingToolConstants.POLYGON);\n    var cp = paths;\n    var newPaths = [];\n    var thisPTool = this;\n\n    //go through each polygon, and take out holes\n    var npIndex = 0;\n\n    var pathStillAlive = function(path) {\n      //if path has segments it is a regular path\n      //if path as children it is a compoundPath\n      //for path or compoundPath to be still "alive" (have positive space)\n      /// segments or children need to have a length > 0\n      return ((path.segments && path.segments.length > 0) ||\n              (path.children && path.children.length > 0))\n    }\n\n    var polygonIndices = [];\n    cp.each(function(value,index) {\n      if( value.data.drawing_type == thisPTool.Constants.POLYGON_DRAWING_TYPE) {\n        polygonIndices.push(index);\n      }\n    });\n\n    var holeIndices = [];\n    cp.each(function(value,index) {\n      if( value.data.drawing_type == thisPTool.Constants.HOLE_DRAWING_TYPE) {\n        holeIndices.push(index);\n      }\n    });\n\n    polygonIndices.each(function(pValue) {\n      newPaths[npIndex] = cp[pValue];\n      var originalData = cp[pValue].data;\n      var subs = 0;\n\n      //go through every hole, subtract from polygon\n      holeIndices.each(function(hValue,hIndex) {\n        //ensure path still has positive space before\n        //subtracting more space from it\n        //make sure hole and polygon paths are same state type\n        //i.e. both hole and polygon path are gold or\n        //     both hole and polygon path are judgment\n        if(originalData.stateType ==\n            cp[hValue].data.stateType) {\n          if( pathStillAlive(newPaths[npIndex]) )  {\n                newPaths[npIndex] =\n                    newPaths[npIndex].subtract(cp[hValue]);\n            subs += 1;\n          }\n        }\n      });\n\n      //if no holes, need to create a new path, otherwise won\'t show up\n      if(holeIndices.length == 0 || subs == 0) {\n        newPaths[npIndex] = new paper.Path(newPaths[npIndex].segments);\n          newPaths[npIndex].data = originalData;\n        newPaths[npIndex].closed = true;\n        newPaths[npIndex].clockwise = true;\n        if(newPaths[npIndex].data.stateType == inst.core.Constants.REGULAR_STATE_TYPE) {\n          correctDrawingTool.saveColorPath(newPaths[npIndex]);\n        }\n        else {\n          inst.core.colorPath(newPaths[npIndex]);\n        }\n        npIndex += 1;\n      }\n      else if( pathStillAlive(newPaths[npIndex]) ) {\n        newPaths[npIndex].data = originalData;\n        if(newPaths[npIndex].data.stateType == inst.core.Constants.REGULAR_STATE_TYPE) {\n          correctDrawingTool.saveColorPath(newPaths[npIndex]);\n        }\n        else {\n          inst.core.colorPath(newPaths[npIndex]);\n        }\n        npIndex += 1;\n      }\n    });\n\n    for(var i = 0; i < cp.length; i++) {\n      this.instance.core.deletePath(cp[i]);\n    }\n    return newPaths;\n  }\n\n\n  function CanvasCore(instanceID,instance) {\n    this.id = instanceID;\n    this.instance = instance;\n    this.img = null;\n  }\n\n  CanvasCore.prototype.renderImageBackground = function(image_url_id) {\n    this.img = new paper.Raster(image_url_id);\n    if (this.img.image.naturalWidth > 0) {\n      var vsize = {width:MAX_VIEW_WIDTH,height:MAX_VIEW_HEIGHT};\n      var r_height_ratio = vsize.height / this.img.height;\n      var r_width_ratio = vsize.width / this.img.width;\n\n      if(this.img.height > this.img.width) {\n        this.img.scale(r_height_ratio,\n          {x:r_height_ratio*this.img.width,y:r_height_ratio*this.img.height});\n\n        paper.view.viewSize =\n          [r_height_ratio*this.img.width,r_height_ratio*this.img.height];\n      }\n      else {\n        this.img.scale(r_width_ratio,\n          {x:r_width_ratio*this.img.width,y:r_width_ratio*this.img.height});\n\n        paper.view.viewSize =\n          [r_width_ratio*this.img.width,r_width_ratio*this.img.height];\n      }\n\n      this.img.position = paper.view.center;\n\n      var newLayer = new paper.Layer();\n      newLayer.activate();\n    }\n  }\n\n  function InstanceCore(instanceID,instance) {\n    this.id = instanceID;\n    this.instance = instance;\n    var activeObjectIndex = null;\n\n    //current paths on canvas\n    var createdPaths = [];\n\n    //saved objects\n    var completedObjects = [];\n\n    //list of drawable objects\n    //note: only single object mode is fully implemented but\n    //having this data structure already enabled will allow\n    //us to implement multi-object mode without too much trouble :)\n    var objectList = [];\n\n    this.resetActiveObject = function() {\n      activeObject = objectList[activeObjectIndex];\n    }\n\n    this.addToObjectList = function (object_to_add) {\n      objectList.push(object_to_add);\n    }\n\n    this.getObjectList = function() {\n      return objectList;\n    }\n\n    this.getActiveObjectIndex = function () {\n      return activeObjectIndex;\n    }\n\n    this.getActiveObject = function () {\n      if(activeObjectIndex != null) {\n        return objectList[activeObjectIndex ];\n      }\n      else {\n        return null;\n      }\n    }\n\n    this.setActiveObjectIndex = function(index) {\n      if(index >= 0 && index < objectList.length) {\n        activeObjectIndex = index;\n      }\n      else {\n        return null;\n      }\n    }\n\n    this.getCreatedPaths = function() {\n      return createdPaths;\n    }\n\n    this.setCreatedPaths = function(cPaths) {\n      createdPaths = cPaths;\n    }\n\n    this.getCompletedObjects = function() {\n      return completedObjects;\n    }\n\n    this.setCompletedObjects = function(cObjects) {\n      var jsonCObjects = JSON.stringify(cObjects);\n      completedObjects = cObjects;\n      jQuery(\'.hidden_field.ia_\'+this.id).attr("value",jsonCObjects);\n    }\n  }\n\n  InstanceCore.prototype.Constants = {\n    //state types are used to differentiate between\n    //gold and unit paths\n    MISSED_GOLD_STATE_TYPE: "missed gold state type",\n    MISSED_UNIT_STATE_TYPE: "missed unit state type",\n    JUDGMENT_OVERLAY_STATE_TYPE: "judgment overlay state type",\n    REGULAR_STATE_TYPE: "regular state type"\n  }\n\n  InstanceCore.prototype.fillSingleObjectList = function() {\n    var object1 = {};\n    object1.name = "Single";\n    object1.paths = [];\n    object1.directions = "";\n    object1.saved = false;\n    this.addToObjectList(object1);\n  }\n\n  //makes given divs specific to this instance by adding\n  //ia_id class to each one\n  //if multiple IA_Instances on a page, this class lets us\n  //know which html belongs to which IA_Instance\n  InstanceCore.prototype.makeHtmlForInstance = function(elem) {\n    var id = this.id;\n    //add ia_id class to first elem\n    var $newSpecificHtml = "<div>"+elem+"</div>";\n\n    //now add ia_id class to all child divs\n    $newSpecificHtml = jQuery($newSpecificHtml).find("*").each( function(c_index,child) {\n      jQuery(child).addClass("ia_"+id);\n    });\n\n    //return a string not an html object\n    return jQuery(\'<div>\').append($newSpecificHtml[0]).clone().html();\n  }\n\n  InstanceCore.prototype.savePathsToActiveObject = function() {\n    var activeObject = this.instance.core.getActiveObject();\n    if(activeObject != null) {\n      activeObject.paths = jQuery.extend(true, [], this.getCreatedPaths());\n    }\n  }\n\n  InstanceCore.prototype.enableDrawingForObject = function(object_index) {\n    this.setActiveObject(object_index);\n    this.instance.menu.drawObjectList();\n    //need to redifine enableDrawingTools in DrawingMenu\n    this.instance.menu.showDrawingTools();\n  }\n\n  InstanceCore.prototype.colorPath = function(path) {\n    var correctDrawingTool = this.instance.menu.getTool(path.data.toolType);\n    if( path.data.stateType == this.Constants.MISSED_GOLD_STATE_TYPE) {\n      correctDrawingTool.goldColorPath(path);\n    }\n    else if( path.data.stateType == this.Constants.MISSED_UNIT_STATE_TYPE) {\n      correctDrawingTool.saveColorPath(path);\n    }\n    else if( path.data.stateType == this.Constants.JUDGMENT_OVERLAY_STATE_TYPE) {\n      var judgmentQueue = path.data.judgmentQueue;\n      //handles up to 30 unique colors for now, will change later\n      var colorFromQueue = new paper.Color(((judgmentQueue % 5) + 1) /5,\n                                            ((judgmentQueue % 2) + 1) /2,\n                                            ((judgmentQueue % 3) + 1) /3,0.8);\n      if(path.data.toolType == DrawingToolConstants.BRUSH ) {\n        path.strokeColor = colorFromQueue;\n        path.strokeWidth = path.data.radius*2;\n        path.strokeCap = \'round\';\n        path.strokeJoin = \'round\';\n      }\n      else {\n        path.fillColor = colorFromQueue;\n      }\n    }\n    else if(path.data.toolType) {\n      correctDrawingTool.colorPath(path);\n    }\n    else {\n      path.fillColor = new paper.Color(1,0,0,0.2);\n    }\n  }\n\n  InstanceCore.prototype.redrawCanvas = function() {\n    var aLayer = paper.project.activeLayer;\n    aLayer.removeChildren();\n    var cp = this.getCreatedPaths();\n\n    cp.each(function(value,index) {\n      aLayer.addChild(value);\n    });\n  }\n\n  //returns array of all used drawingTools of given paths\n  InstanceCore.prototype.drawingToolsFromPaths = function(paths) {\n    var toolTypes = [];\n    for(var j = 0; j < paths.length; j++) {\n      if(jQuery.inArray(paths[j].data.toolType,toolTypes) == -1) {\n        toolTypes.push(paths[j].data.toolType)\n      }\n    }\n    return toolTypes;\n  }\n\n  //returns all paths that use the given drawingTool from the\n  //given paths\n  InstanceCore.prototype.pathsFromDrawingTool = function(paths,drawingTool) {\n    var correctPaths = [];\n    for(var j = 0; j < paths.length; j++) {\n      if(paths[j].data.toolType == drawingTool) {\n        correctPaths.push(paths[j])\n      }\n    }\n    return correctPaths;\n  }\n\n  InstanceCore.prototype.addToCreatedPaths = function(path_to_add) {\n    var createdPaths = this.getCreatedPaths();\n    createdPaths.push(path_to_add);\n    this.instance.menu.drawCurrentObjPathList();\n  }\n\n  //// DRAWING TOOLS USE THIS FUNCTION WHEN ADDING NEW PATHS\n  InstanceCore.prototype.addNewPath = function(pathToAdd, toolType) {\n    var createdPaths = this.getCreatedPaths();\n    pathToAdd.data.toolType = toolType;\n    pathToAdd.data.stateType = this.Constants.REGULAR_STATE_TYPE\n    this.colorPath(pathToAdd);\n    createdPaths.push(pathToAdd);\n    this.instance.menu.drawCurrentObjPathList();\n  }\n\n  InstanceCore.prototype.setActiveObject = function(index_of_object) {\n    this.setActiveObjectIndex(index_of_object);\n    var activeObject = this.getActiveObject();\n    var objPaths = activeObject.paths;\n    for(var i = 0; i < objPaths.length; i++) {\n      this.addPathToActiveLayer(objPaths[i]);\n    }\n    this.instance.menu.drawPathList();\n  }\n\n\n  InstanceCore.prototype.deletePath = function(path_to_delete) {\n    var createdPaths = this.getCreatedPaths();\n    var correctDrawingTool = this.instance.menu.getTool(path_to_delete.data.toolType);\n\n    var newPathList =\n      correctDrawingTool.removePathFromPathList(path_to_delete);\n\n    correctDrawingTool.removePath(path_to_delete);\n    this.setCreatedPaths(newPathList);\n    this.instance.menu.drawPathList();\n  }\n\n  InstanceCore.prototype.addPathToActiveLayer = function(elem) {\n    var path = new paper.Path(elem.segments);\n    path.closed = elem.closed;\n    path.data = elem.data;\n    this.colorPath(path);\n    this.addToCreatedPaths(path);\n  }\n\n  InstanceCore.prototype.deleteObject = function( objectToDelete ) {\n    var removeFromObjectList = function(obj_to_remove) {\n      var temp = [];\n      objectList.each(function(value,index) {\n        if( value.name == obj_to_remove.name) {\n        }\n        else {\n          temp.push(value);\n        }\n      });\n      objectList = temp;\n    }\n\n    for(var i = 0; i < objectToDelete.paths.length; i++) {\n      this.deletePath(objectToDelete.paths[i]);\n    }\n    removeFromObjectList( object_to_delete );\n  }\n\n\n  function SaveLoadSystem(instanceID,instance) {\n    this.id = instanceID;\n    this.instance = instance;\n  }\n\n  SaveLoadSystem.prototype.JsonToObjectList = function(json) {\n    // this obj will have annotations that are resized to fit\n    // the page\n    var $obj = jQuery.parseJSON(json);\n    // this obj will represent our saved annotation with original\n    // annotation sizes\n    var $completedObj = jQuery.extend(true, [], $obj);\n    for(var i = 0; i < $obj.length; i++) {\n      $obj[i].paths = this.afterJsonPathsConversion($obj[i].paths);\n      $completedObj[i].paths = this.afterJsonPathsConversion($completedObj[i].paths);\n      for(var j = 0; j < $obj[i].paths.length; j++) {\n        $obj[i].paths[j] = this.newPathFromObjNoShow($obj[i].paths[j]);\n        $completedObj[i].paths[j] =\n          this.newPathFromObjNoShowNoTrans($completedObj[i].paths[j]);\n      }\n      $obj[i].saved = false;\n      this.instance.core.addToObjectList($obj[i]);\n    }\n    // set completed obj to non-translated objects as if no save occurs,\n    // we need the object to have it\'s original annotation sizes\n    this.instance.core.setCompletedObjects($completedObj);\n  }\n\n  //after loading path objects from json they are in the form\n  //[["Path",path1_obj],["Path",path2_obj]] so to get to the guts of the path\n  // it has to be accessed at path[i][1]\n  //the function below strips the string label and leaves it\n  //[path1_obj, path2_obj]\n  SaveLoadSystem.prototype.afterJsonPathsConversion = function(paths) {\n    var newPaths = []\n    for(var i = 0; i < paths.length; i++) {\n      newPaths.push(paths[i][1]);\n    }\n    return newPaths\n  }\n\n  SaveLoadSystem.prototype.saveDrawing = function() {\n    changeActiveInstance(this.id);\n    var id = this.id;\n    var inst = this.instance;\n\n    var editPaths = this.instance.preview.getEditPaths();\n    var aObject = this.instance.core.getActiveObject();\n\n\n    var transPathCanvasToImg = function(path,inst) {\n      var scalingFactor = 0;\n      var translateFactor = {dx: 0, dy: 0};\n      var canvasSize = paper.projects[id].view.viewSize;\n      var img = inst.canvasCore.img;\n\n      if( canvasSize.height > canvasSize.width) {\n        scalingFactor = img.height / canvasSize.height;\n      }\n      else {\n        scalingFactor = img.width / canvasSize.width;\n      }\n\n      translateFactor.dx = (img.width - canvasSize.width*scalingFactor) / 2;\n      translateFactor.dy = (img.height - canvasSize.height*scalingFactor) / 2;\n\n      var scalingMatrix = new paper.Matrix();\n      scalingMatrix.scale(scalingFactor);\n\n      var translateMatrix = new paper.Matrix();\n      translateMatrix.translate(translateFactor.dx,translateFactor.dy);\n\n      //canvas -> img\n      //translate then scale\n      path.transform(translateMatrix);\n      path.transform(scalingMatrix);\n    }\n\n\n    if(editPaths != null) {\n      var jsonPaths = JSON.stringify(editPaths);\n    }\n    else {\n      inst.preview.toPreview();\n      editPaths = inst.preview.getEditPaths()\n      var jsonPaths = JSON.stringify(editPaths);\n    }\n    if(jsonPaths.length > MAX_CHARACTERS) {\n      alert("You drew too much! \\nMax drawing length allowed:" + MAX_CHARACTERS +\n            "\\nYour drawing length: " + jsonPaths.length);\n      inst.preview.backToEdit();\n      return false;\n    }\n    else {\n      editPaths.each(function(value) {\n        var correctDrawingTool = inst.menu.getTool(value.data.toolType);\n        correctDrawingTool.saveColorPath(value);\n      });\n      // set activeObject paths to editPaths\n      // this is done because some drawing tools use different formats\n      // for saved paths versus non-saved paths\n      // example: line tool has two circular end points when not saved,\n      // for visual purposes, and only two points when saved\n      finalObjectPaths = [];\n      for(var i = 0; i < editPaths.length; i++) {\n        finalObjectPaths.push(this.newPathFromObjNoShowNoTrans(editPaths[i]))\n      }\n\n      aObject.paths = finalObjectPaths;\n      aObject.saved = true;\n      aObject.paths.each(function(value) {\n        value.data.saved = true;\n      });\n\n      for(var j = 0; j < aObject.paths.length; j++) {\n        transPathCanvasToImg(aObject.paths[j],this.instance);\n      }\n\n      this.instance.core.setCompletedObjects([aObject]);\n      jQuery(\'.cf_action_list.ia_\'+id+\' .finished_msg\').fadeIn();\n      // Hack to trigger save button of tq editor\n      var gold_field = jQuery(\'.image_annotation_instance_gold.ia_\'+id)[0]\n      if (gold_field) {\n        gold_field.fireEvent(\'change\');\n      }\n      return true;\n    }\n  }\n\n  SaveLoadSystem.prototype.missedGoldFromJSONJudgmentOverlay = function(gold,judgments) {\n    var newLayer = null;\n    var finishedPaths = [];\n\n    for(var j = 0; j < gold.paths.length; j++) {\n      gold.paths[j].data.stateType = this.instance.core.Constants.MISSED_GOLD_STATE_TYPE;\n      gold.paths[j] = this.newPathFromObjShow(gold.paths[j]);\n    }\n\n    if(judgments != null) {\n      for(var i = 0; i < judgments.length; i++) {\n        for(var j = 0; j < judgments[i][0].paths.length; j++) {\n          judgments[i][0].paths[j].data.stateType = this.instance.core.Constants.JUDGMENT_OVERLAY_STATE_TYPE;\n          judgments[i][0].paths[j].data.judgmentQueue = i;\n          gold.paths.push(this.newPathFromObjShow(judgments[i][0].paths[j]));\n        }\n      }\n    }\n\n\n    this.instance.core.addToObjectList(gold);\n\n    var aLayer = paper.projects[this.id].activeLayer;\n    aLayer.removeChildren();\n\n    //activate new layer for holes\n    newLayer = new paper.Layer();\n    paper.projects[this.id].activeLayer = newLayer;\n\n    // get all drawing tools used in gold[0] paths\n    var toolTypes = this.instance.core.drawingToolsFromPaths(gold.paths);\n\n    this.instance.menu = new DrawingMenu(toolTypes,this.id,this.instance);\n\n    // for each drawing tool\n      // get paths used for that drawing tool in gold[0] paths\n      // apply correct previewPaths function to those paths\n    finishedPaths = [];\n    for(var i = 0; i < this.instance.menu.drawingTools.length; i++) {\n      //gen correct drawing_tool paths here\n      var currentDrawingToolPaths =\n        this.instance.core.pathsFromDrawingTool(gold.paths,this.instance.menu.drawingTools[i].getToolType());\n      finishedPaths.push.apply(finishedPaths,\n        this.instance.menu.drawingTools[i].previewPaths(currentDrawingToolPaths));\n    }\n    return finishedPaths;\n  }\n\n  SaveLoadSystem.prototype.missedGoldFromJSONsingleObject = function(gold,unit) {\n    var newLayer = null;\n    var finishedPaths = [];\n\n    for(var j = 0; j < gold.paths.length; j++) {\n      gold.paths[j].data.stateType = this.instance.core.Constants.MISSED_GOLD_STATE_TYPE;\n      gold.paths[j] = this.newPathFromObjShow(gold.paths[j]);\n    }\n\n    if(unit != null) {\n      for(var j = 0; j < unit.paths.length; j++) {\n        unit.paths[j].data.stateType = this.instance.core.Constants.MISSED_UNIT_STATE_TYPE;\n        gold.paths.push(this.newPathFromObjShow(unit.paths[j]));\n      }\n    }\n\n    this.instance.core.addToObjectList(gold);\n\n    var aLayer = paper.projects[this.id].activeLayer;\n    aLayer.removeChildren();\n\n    //activate new layer for holes\n    newLayer = new paper.Layer();\n    paper.projects[this.id].activeLayer = newLayer;\n\n    // get all drawing tools used in gold[0] paths\n    var toolTypes = this.instance.core.drawingToolsFromPaths(gold.paths);\n\n    this.instance.menu = new DrawingMenu(toolTypes,this.id,this.instance);\n\n    // for each drawing tool\n      // get paths used for that drawing tool in gold[0] paths\n      // apply correct previewPaths function to those paths\n    finishedPaths = [];\n    for(var i = 0; i < this.instance.menu.drawingTools.length; i++) {\n      //gen correct drawing_tool paths here\n      var currentDrawingToolPaths =\n        this.instance.core.pathsFromDrawingTool(gold.paths,this.instance.menu.drawingTools[i].getToolType());\n      finishedPaths.push.apply(finishedPaths,\n        this.instance.menu.drawingTools[i].previewPaths(currentDrawingToolPaths));\n    }\n    return finishedPaths;\n  }\n\n  SaveLoadSystem.prototype.newPathFromObjShow = function(objPath) {\n    var newPath = new paper.Path(objPath.segments);\n    newPath.data = objPath.data;\n    newPath.data.saved = false;\n    this.instance.core.colorPath(newPath);\n    newPath.closed = objPath.closed;\n    newPath.clockwise = objPath.clockwise;\n    this.transPathImgToCanvas(newPath);\n    return newPath;\n  }\n\n  SaveLoadSystem.prototype.newPathFromObjNoShow = function(objPath) {\n    var tempLayer = new paper.Layer();\n    paper.projects[this.id].setActiveLayer = tempLayer;\n    var newPath = new paper.Path(objPath.segments);\n    newPath.data = objPath.data;\n    newPath.data.saved = false;\n    this.instance.core.colorPath(newPath);\n    newPath.closed = objPath.closed;\n    newPath.clockwise = objPath.clockwise;\n    this.transPathImgToCanvas(newPath);\n    tempLayer.remove();\n    return newPath;\n  }\n\n  SaveLoadSystem.prototype.newPathFromObjNoShowNoTrans = function(objPath) {\n    var tempLayer = new paper.Layer();\n    paper.projects[this.id].setActiveLayer = tempLayer;\n    var newPath = new paper.Path(objPath.segments);\n    newPath.data = objPath.data;\n    newPath.data.saved = false;\n    this.instance.core.colorPath(newPath);\n    newPath.closed = objPath.closed;\n    newPath.clockwise = objPath.clockwise;\n    tempLayer.remove();\n    return newPath;\n  }\n\n  SaveLoadSystem.prototype.transPathImgToCanvas = function(path) {\n    var scalingFactor = 0;\n    var translateFactor = {dx: 0, dy: 0};\n    var canvasSize = paper.projects[this.id].view.viewSize;\n    var img = this.instance.canvasCore.img;\n\n    if( img.height > img.width) {\n      scalingFactor = canvasSize.height / img.height;\n    }\n    else {\n      scalingFactor = canvasSize.width / img.width;\n    }\n\n    translateFactor.dx = (canvasSize.width - img.width*scalingFactor) / 2;\n    translateFactor.dy = (canvasSize.height - img.height*scalingFactor) / 2;\n\n    //img -> canvas\n    //scale then translate\n    var scalingMatrix = new paper.Matrix();\n    scalingMatrix.scale(scalingFactor);\n\n    var translateMatrix = new paper.Matrix();\n    translateMatrix.translate(translateFactor.dx,translateFactor.dy);\n\n    path.transform(scalingMatrix);\n    path.transform(translateMatrix);\n  }\n\n\n\n  function PreviewSystem(instanceID,instance) {\n    this.id = instanceID;\n    this.instance = instance;\n    var previewLayer = null;\n    var editPaths = null;\n\n    this.getEditPaths = function() {\n      return editPaths;\n    }\n\n    this.setEditPaths = function(newEditPaths) {\n      editPaths = newEditPaths;\n    }\n\n    this.getPreviewLayer = function() {\n      return previewLayer;\n    }\n\n    this.setPreviewLayer = function(newPreviewLayer) {\n      previewLayer = newPreviewLayer;\n    }\n  }\n\n  PreviewSystem.prototype.backToEdit = function () {\n    var inst = this.instance;\n    changeActiveInstance(this.id);\n    var new_layer = this.getPreviewLayer();\n\n    new_layer.children.each(function(value,index) {\n      value.data.saved = false;\n    });\n\n    new_layer.removeChildren();\n    new_layer.remove();\n    inst.core.resetActiveObject();\n\n    var activeObject = inst.core.getActiveObject();\n    var aLayer = paper.project.activeLayer;\n    aLayer.removeChildren();\n\n    activeObject.paths.each(function(value,index) {\n      aLayer.addChild(value);\n      inst.core.addToCreatedPaths(value);\n    });\n\n    this.setEditPaths(null);\n\n    inst.menu.showDrawingTools();\n\n    jQuery(\'.cf_action_list.ia_\'+this.id+\' .render_holes\').fadeIn();\n    jQuery(\'.cf_action_list.ia_\'+this.id+\' .edit_holes\').hide();\n    jQuery(\'.cf_action_list.ia_\'+this.id+\' .done_drawing_preview\').hide();\n  }\n\n  PreviewSystem.prototype.toPreview = function() {\n    changeActiveInstance(this.id);\n    var inst = this.instance;\n    tempEditPaths = [];\n\n    //save paths to objectList\n    if( inst.core.getActiveObject != null) {\n      inst.core.savePathsToActiveObject();\n    }\n\n    var aLayer = paper.project.activeLayer;\n    aLayer.removeChildren();\n\n    //activate new layer for holes\n    this.setPreviewLayer(new paper.Layer());\n    this.getPreviewLayer().activate();\n\n    tempEditPaths = [];\n    for(var i = 0; i < inst.menu.drawingTools.length; i++) {\n      //gen correct drawing_tool paths here\n      var currentDrawingToolPaths =\n        inst.core.pathsFromDrawingTool(inst.core.getCreatedPaths(),inst.menu.drawingTools[i].getToolType());\n      tempEditPaths.push.apply(tempEditPaths,\n        inst.menu.drawingTools[i].previewPaths(currentDrawingToolPaths));\n    }\n\n    this.setEditPaths(tempEditPaths);\n    return tempEditPaths;\n  }\n\n  function UndoRedoSystem(instanceID,instance) {\n    this.id = instanceID;\n    this.instance = instance;\n    var savedCPStates = [[]];\n    var savedCPStatesCurrentIndex = 0;\n\n    this.getSavedCPStatesIndex = function() {\n      return savedCPStatesCurrentIndex;\n    }\n\n    this.setSavedCPStatesIndex = function(newIndex) {\n      savedCPStatesCurrentIndex = newIndex;\n    }\n\n    this.canUndo = function() {\n      return (savedCPStatesCurrentIndex < savedCPStates.length - 1);\n    }\n\n    this.canRedo = function() {\n      return (savedCPStatesCurrentIndex > 0);\n    }\n\n    this.getSavedCPStates = function() {\n      return savedCPStates;\n    }\n\n    this.setSavedCPStates = function(newStates) {\n      savedCPStates = newStates;\n    }\n  }\n\n  UndoRedoSystem.prototype.undoCPState = function() {\n    var savedCPStatesCurrentIndex = this.getSavedCPStatesIndex();\n    var savedCPStates = this.getSavedCPStates();\n\n    if(this.canUndo()) {\n      savedCPStatesCurrentIndex += 1;\n      this.setSavedCPStatesIndex(savedCPStatesCurrentIndex);\n      var scp = this.makeNewPathList(savedCPStates[savedCPStatesCurrentIndex]);\n      this.instance.core.setCreatedPaths(scp);\n    }\n  }\n\n  UndoRedoSystem.prototype.redoCPState = function() {\n    var savedCPStatesCurrentIndex = this.getSavedCPStatesIndex();\n    var savedCPStates = this.getSavedCPStates();\n\n    if(this.canRedo()) {\n      savedCPStatesCurrentIndex -= 1;\n      this.setSavedCPStatesIndex(savedCPStatesCurrentIndex);\n      var scp = this.makeNewPathList(savedCPStates[savedCPStatesCurrentIndex]);\n      this.instance.core.setCreatedPaths(scp);\n    }\n  }\n\n  UndoRedoSystem.prototype.makeNewPathList = function(pathsToCopy) {\n    var scp = [];\n    for(var j = 0; j < pathsToCopy.length; j++) {\n      var temp = new paper.Path(pathsToCopy[j].segments);\n      temp.data = pathsToCopy[j].data;\n      this.instance.core.colorPath(temp)\n      temp.clockwise = true;\n      temp.closed = pathsToCopy[j].closed;\n      scp.push(temp);\n    }\n    return scp;\n  }\n\n  UndoRedoSystem.prototype.saveCPState = function() {\n    var savedCPStates = this.getSavedCPStates();\n    var savedCPStatesCurrentIndex = this.getSavedCPStatesIndex();\n\n    paper.projects[this.id].activeLayer.removeChildren();\n\n    var i = 0;\n    var cp = jQuery.extend(true, [], this.instance.core.getCreatedPaths());\n    var jk = jQuery.extend(true, [], savedCPStates);\n    var scp = this.makeNewPathList(cp);\n\n    while(i != savedCPStatesCurrentIndex) {\n      savedCPStates.shift();\n      i += 1;\n    }\n\n    savedCPStatesCurrentIndex = 0;\n    savedCPStates.unshift(cp);\n\n    this.setSavedCPStates(savedCPStates);\n    this.setSavedCPStatesIndex(savedCPStatesCurrentIndex);\n    this.instance.core.setCreatedPaths(scp);\n    this.instance.core.redrawCanvas();\n    this.redrawUndoRedoLinks();\n  }\n\n  UndoRedoSystem.prototype.redrawUndoRedoLinks = function() {\n    if(this.canUndo()) {\n      jQuery(\'.cf_action_list.ia_\'+this.id+\' .cf_undo\').removeClass("disabled");\n      jQuery(\'.cf_action_list.ia_\'+this.id+\' .cf_undo\').addClass("enabled");\n    }\n    else {\n      jQuery(\'.cf_action_list.ia_\'+this.id+\' .cf_undo\').removeClass("enabled");\n      jQuery(\'.cf_action_list.ia_\'+this.id+\' .cf_undo\').addClass("disabled");\n    }\n\n    if(this.canRedo()) {\n      jQuery(\'.cf_action_list.ia_\'+this.id+\' .cf_redo\').removeClass("disabled");\n      jQuery(\'.cf_action_list.ia_\'+this.id+\' .cf_redo\').addClass("enabled");\n    }\n    else {\n      jQuery(\'.cf_action_list.ia_\'+this.id+\' .cf_redo\').removeClass("enabled");\n      jQuery(\'.cf_action_list.ia_\'+this.id+\' .cf_redo\').addClass("disabled");\n    }\n  }\n\n  // initialize ia once dom is loaded\n  jQuery(function() {init();});\n\n  jQuery.each(DrawingToolConstants, function(key,value) {\n    jQuery(\'.ia_container\').on("click",".ia_"+value+"_tool", function() {\n      var pIndex = getProjectIndexFromElement(this);\n      var dTool = iaInstanceList[pIndex].menu.getTool(value);\n      iaInstanceList[pIndex].menu.setActiveTool(dTool.getToolType());\n      iaInstanceList[pIndex].menu.enableActiveTool();\n      iaInstanceList[pIndex].menu.redrawActiveTool();\n    });\n  });\n\n  jQuery(\'.ia_container\').on("click",".draw_polygon", function() {\n    var pIndex = getProjectIndexFromElement(this);\n    var dTool = iaInstanceList[pIndex].menu.getToolFromHtml(this);\n    iaInstanceList[pIndex].menu.setActiveTool(dTool.getToolType());\n    iaInstanceList[pIndex].menu.enableActiveTool();\n    iaInstanceList[pIndex].menu.redrawActiveTool();\n    iaInstanceList[pIndex].menu.getToolFromHtml(this).setPolygonDrawingType();\n\n    jQuery( ".draw_hole.ia_" + pIndex).addClass("off");\n\n    jQuery( ".draw_polygon.ia_" + pIndex ).removeClass("off");\n  });\n\n  jQuery(\'.ia_container\').on("click",".free_draw_off", function() {\n    var pIndex = getProjectIndexFromElement(this);\n    var dTool = iaInstanceList[pIndex].menu.getToolFromHtml(this);\n    iaInstanceList[pIndex].menu.setActiveTool(dTool.getToolType());\n    iaInstanceList[pIndex].menu.enableActiveTool();\n    iaInstanceList[pIndex].menu.redrawActiveTool();\n    iaInstanceList[pIndex].menu.getToolFromHtml(this).setSelectionMode();\n\n    jQuery( ".free_draw_on.ia_"+ pIndex ).addClass("off");\n\n    jQuery( ".free_draw_off.ia_"+ pIndex).removeClass("off");\n  });\n\n  jQuery(\'.ia_container\').on("click",".free_draw_on", function() {\n    var pIndex = getProjectIndexFromElement(this);\n    var dTool = iaInstanceList[pIndex].menu.getToolFromHtml(this);\n    iaInstanceList[pIndex].menu.setActiveTool(dTool.getToolType());\n    iaInstanceList[pIndex].menu.enableActiveTool();\n    iaInstanceList[pIndex].menu.redrawActiveTool();\n    iaInstanceList[pIndex].menu.getToolFromHtml(this).setFreeDrawMode();\n\n    jQuery( ".free_draw_off.ia_"+ pIndex).addClass("off");\n\n    jQuery( ".free_draw_on.ia_"+ pIndex).removeClass("off");\n  });\n\n  jQuery(\'.ia_container\').on("click",".line_draw", function() {\n    var pIndex = getProjectIndexFromElement(this);\n    var dTool = iaInstanceList[pIndex].menu.getToolFromHtml(this);\n    iaInstanceList[pIndex].menu.setActiveTool(dTool.getToolType());\n    iaInstanceList[pIndex].menu.enableActiveTool();\n    iaInstanceList[pIndex].menu.redrawActiveTool();\n\n    jQuery( ".line_draw.ia_"+ pIndex).removeClass("off");\n  });\n\n  jQuery(\'.ia_container\').on("click",".render_holes",function() {\n    iaInstanceList[activeInstance].preview.toPreview();\n    jQuery(\'.cf_action_list.ia_\'+activeInstance+\' .render_holes\').hide();\n    jQuery(\'.cf_action_list.ia_\'+activeInstance+\' .edit_holes\').fadeIn();\n    jQuery(\'.cf_action_list.ia_\'+activeInstance+\' .done_drawing_preview\').fadeIn();\n    iaInstanceList[activeInstance].menu.disableDrawingTools();\n  });\n\n  jQuery(\'.ia_container\').on("click", ".edit_holes", function() {\n    iaInstanceList[activeInstance].preview.backToEdit();\n  });\n\n  jQuery(\'.ia_container\').on("click",".draw_hole", function() {\n    var pIndex = getProjectIndexFromElement(this);\n    var dTool = iaInstanceList[pIndex].menu.getToolFromHtml(this);\n    iaInstanceList[pIndex].menu.setActiveTool(dTool.getToolType());\n    iaInstanceList[pIndex].menu.enableActiveTool();\n    iaInstanceList[pIndex].menu.redrawActiveTool();\n    iaInstanceList[pIndex].menu.getToolFromHtml(this).setHoleDrawingType();\n\n    jQuery( ".draw_polygon.ia_"+\n      pIndex ).addClass("off");\n\n    jQuery( ".draw_hole.ia_" +\n      pIndex ).removeClass("off");\n  });\n\n  jQuery(\'.ia_container\').on("click", ".cf_undo", function() {\n    iaInstanceList[activeInstance].undoRedo.undoCPState();\n    iaInstanceList[activeInstance].core.redrawCanvas();\n    iaInstanceList[activeInstance].menu.drawPathList();\n    iaInstanceList[activeInstance].undoRedo.redrawUndoRedoLinks();\n  });\n\n  jQuery(document).on("keydown", function(e) {\n    //if ctrl + z was pressed, undo!\n    if( jQuery(\'.cf_action_list.ia_\'+activeInstance + \' .cf_undo\').is(":visible") &&\n        jQuery(\'.ia_container.ia_\'+activeInstance).is(":hovering") &&\n        iaInstanceList[activeInstance].undoRedo.canUndo() &&\n        (e.which == 90 && e.ctrlKey)) {\n\n      //uses the active instance\n      iaInstanceList[activeInstance].undoRedo.undoCPState();\n      iaInstanceList[activeInstance].core.redrawCanvas();\n      iaInstanceList[activeInstance].menu.drawPathList();\n      iaInstanceList[activeInstance].undoRedo.redrawUndoRedoLinks();\n    }\n  });\n\n  jQuery(\'.ia_container\').on("click", ".cf_redo", function() {\n    iaInstanceList[activeInstance].undoRedo.redoCPState();\n    iaInstanceList[activeInstance].core.redrawCanvas();\n    iaInstanceList[activeInstance].menu.drawPathList();\n    iaInstanceList[activeInstance].undoRedo.redrawUndoRedoLinks();\n  });\n\n  jQuery(document).on(\'mouseenter\',\'.ia_container\', function() {\n      jQuery(this).data(\'hovering\', true);\n  });\n  jQuery(document).on(\'mouseleave\',\'.ia_container\', function() {\n      jQuery(this).data(\'hovering\', false);\n  });\n\n  jQuery.expr[":"].hovering = function(elem) {\n    return jQuery(elem).data(\'hovering\') ? true : false;\n  };\n\n  jQuery(document).on("keydown", function(e) {\n    //if ctrl + y was pressed, redo!\n    if( jQuery(\'.cf_action_list.ia_\'+activeInstance + \' .cf_redo\').is(":visible") &&\n        jQuery(\'.ia_container.ia_\'+activeInstance).is(":hovering") &&\n        iaInstanceList[activeInstance].undoRedo.canRedo() &&\n        (e.which == 89 && e.ctrlKey)) {\n\n      iaInstanceList[activeInstance].undoRedo.redoCPState();\n      iaInstanceList[activeInstance].core.redrawCanvas();\n      iaInstanceList[activeInstance].menu.drawPathList();\n      iaInstanceList[activeInstance].undoRedo.redrawUndoRedoLinks();\n    }\n  });\n\n  jQuery(".ia_container").on( {\n    mouseenter: function() {\n      var pIndex = getProjectIndexFromElement(this);\n      var inst = iaInstanceList[pIndex];\n      var index = this.id;\n      var path = inst.core.getCreatedPaths()[index];\n      var correctDrawingTool = inst.menu.getTool(path.data.toolType);\n      correctDrawingTool.highlightColorPath(path);\n    },\n    mouseleave: function() {\n      var pIndex = getProjectIndexFromElement(this);\n      var inst = iaInstanceList[pIndex];\n      var index = this.id;\n      var path = inst.core.getCreatedPaths()[index];\n      var correctDrawingTool = inst.menu.getTool(path.data.toolType);\n      correctDrawingTool.backFromHighlightColorPath(path);\n    }\n  }, ".delete_path");\n\n  jQuery(\'.ia_container\').on("click",".delete_path", function() {\n    var pIndex = getProjectIndexFromElement(this);\n    var inst = iaInstanceList[pIndex];\n    var index = this.id;\n    var path = inst.core.getCreatedPaths()[index];\n    var correctDrawingTool = inst.menu.getTool(path.data.toolType);\n    // if line tool delete main path and two end paths!\n    inst.core.deletePath(path);\n    inst.undoRedo.saveCPState();\n  });\n\n  jQuery(\'.ia_container\').on("click",".done_drawing_preview", function() {\n    if(iaInstanceList[activeInstance].saveLoad.saveDrawing()) {\n      jQuery(\'.cf_action_list.ia_\'+activeInstance+\' .edit_holes\').hide();\n      jQuery(\'.cf_action_list.ia_\'+activeInstance+\' .done_drawing_preview\').hide();\n      iaInstanceList[activeInstance].menu.disableDrawingTools();\n    }\n  });\n\n  jQuery(\'.ia_container\').on("click",".done_drawing", function() {\n    if(iaInstanceList[activeInstance].saveLoad.saveDrawing()) {\n      jQuery(\'.cf_action_list.ia_\'+activeInstance+\' .render_holes\').hide();\n      iaInstanceList[activeInstance].menu.disableDrawingTools();\n    }\n  });\n\n  jQuery(".ia_container").on( {\n    mouseenter: function() {\n      var pIndex = getProjectIndexFromElement(this);\n      var inst = iaInstanceList[pIndex];\n      var index = this.id;\n      var path = inst.core.getCreatedPaths()[index];\n      var correctDrawingTool = inst.menu.getTool(path.data.toolType);\n      correctDrawingTool.highlightColorPath(path);\n    },\n    mouseleave: function() {\n      var pIndex = getProjectIndexFromElement(this);\n      var inst = iaInstanceList[pIndex];\n      var index = this.id;\n      var path = inst.core.getCreatedPaths()[index];\n      var correctDrawingTool = inst.menu.getTool(path.data.toolType);\n      correctDrawingTool.backFromHighlightColorPath(path);\n    }\n  }, ".highlight_path");\n\n  jQuery(\'.ia_container\').on("click",".small_radius.b_off", function() {\n      var pIndex = getProjectIndexFromElement(this);\n      var dTool = iaInstanceList[pIndex].menu.getToolFromHtml(this);\n      iaInstanceList[pIndex].menu.setActiveTool(dTool.getToolType());\n      iaInstanceList[pIndex].menu.enableActiveTool();\n      iaInstanceList[pIndex].menu.redrawActiveTool();\n      dTool.setSmallRadius();\n      dTool.showHtml();\n  });\n\n  jQuery(\'.ia_container\').on("click",".medium_radius.b_off", function() {\n      var pIndex = getProjectIndexFromElement(this);\n      var dTool = iaInstanceList[pIndex].menu.getToolFromHtml(this);\n      iaInstanceList[pIndex].menu.setActiveTool(dTool.getToolType());\n      iaInstanceList[pIndex].menu.enableActiveTool();\n      iaInstanceList[pIndex].menu.redrawActiveTool();\n      dTool.setMediumRadius();\n      dTool.showHtml();\n  });\n\n  jQuery(\'.ia_container\').on("click",".medium_large_radius.b_off", function() {\n      var pIndex = getProjectIndexFromElement(this);\n      var dTool = iaInstanceList[pIndex].menu.getToolFromHtml(this);\n      iaInstanceList[pIndex].menu.setActiveTool(dTool.getToolType());\n      iaInstanceList[pIndex].menu.enableActiveTool();\n      iaInstanceList[pIndex].menu.redrawActiveTool();\n      dTool.setMediumLargeRadius();\n      dTool.showHtml();\n  });\n\n  jQuery(\'.ia_container\').on("click",".large_radius.b_off", function() {\n      var pIndex = getProjectIndexFromElement(this);\n      var dTool = iaInstanceList[pIndex].menu.getToolFromHtml(this);\n      iaInstanceList[pIndex].menu.setActiveTool(dTool.getToolType());\n      iaInstanceList[pIndex].menu.enableActiveTool();\n      iaInstanceList[pIndex].menu.redrawActiveTool();\n      dTool.setLargeRadius();\n      dTool.showHtml();\n  });\n\n  function getProjectIndexFromContainer(container) {\n    var pIndex = null;\n    paper.projects.each( function(item,index) {\n      if(\'ia_container ia_\'+index == container) {\n        pIndex = index;\n      }\n    });\n    return pIndex;\n  }\n\n  function getProjectIndexFromElement(element) {\n    var pIndex = null;\n    paper.projects.each( function(item,index) {\n      jQuery(element).attr(\'class\').split(\' \').each (function(c) {\n        if(c == \'ia_\'+index) {\n          pIndex = index;\n          return pIndex;\n        }\n      });\n    });\n    return pIndex;\n  }\n\n\n  function init() {\n    var iaCount = 0;\n    jQuery(".ia_initialize").each( function(index,elem) {\n      iaCount += 1;\n\n      //set index of canvas\n      jQuery(elem).find(\'canvas\').attr("id","ia_canvas_"+index);\n      jQuery(elem).find(\'.ia_tools\').addClass("ia_"+index);\n\n      var canvas = document.getElementById(\'ia_canvas_\'+index);\n      paper.setup(canvas);\n\n      //create new image annotation instance, with index\n      var iaObj = new IA_Instance(index);\n      var tools = jQuery(".ia_tools.ia_"+index).data("ia-tools").split(\' \');\n      iaInstanceList.push(iaObj);\n      iaObj.createSystems(tools);\n\n      //set up children with index\n      jQuery(elem).find(\'div, img, input\').each( function(c_index,child) {\n        jQuery(child).addClass("ia_" + index);\n      });\n      jQuery(elem).find(\'img\').attr("id","ia_imgurl_"+index);\n\n      //init and append correct tools to iaObj\'s menu\n      iaObj.menu.initMenu();\n      iaObj.menu.addToolsToMenu();\n\n      //render image on canvas\n      //wait until the image is loaded\n      iaImg = jQuery(elem).find(\'img\');\n      if (iaImg[0].width > 0) {\n        setupElement(iaObj, index);\n      } else {\n        iaImg.on(\'load\', function() {\n          setupElement(iaObj, index);\n        });\n      }\n    });\n    if( iaCount > 0) {\n      changeActiveInstance(0);\n    }\n  }\n\n  function setupElement(iaObj, index) {\n    iaObj.canvasCore.renderImageBackground("ia_imgurl_"+index);\n    //gold data created by job creator\n    var goldDataElem = jQuery("input.hidden_field.image-annotation.ia_"+index)[0];\n\n    // if true we know we are showing gold to job creator (show gold)\n    var savedGold = jQuery(".metadata.ia_"+index).data("rendering-missed");\n\n    //judgment data to only be shown when comparing judgment data to gold data\n    var judgmentDataElem = jQuery(".ia_container.ia_"+index).closest(".missed").find(".judgment_data")[0];\n\n    //shows gold reason in gold edit form\n    jQuery(".cml_gold_reason").parent().css("height","103px");\n    jQuery(".cml_gold_reason").css("margin","0");\n\n    if(judgmentDataElem != null) {\n      //showing missed gold to contributor\n      var judgmentData = judgmentDataElem.data("judgment-data");\n      var goldData = jQuery.parseJSON(goldDataElem.value);\n      goldData[0].paths = iaObj.saveLoad.afterJsonPathsConversion(goldData[0].paths)\n      judgmentData[0].paths = iaObj.saveLoad.afterJsonPathsConversion(judgmentData[0].paths)\n      if(goldData.length == 1) {\n        //change from image relative to canvas relative coordinates\n        iaObj.saveLoad.missedGoldFromJSONsingleObject(goldData[0],judgmentData[0]);\n        iaObj.menu.disableDrawingTools();\n      }\n      else {\n        //multi object\n      }\n      jQuery(\'.cf_action_list.ia_\'+index).remove();\n    }\n    else if(savedGold == true) {\n      //showing gold to job creator\n      jQuery(".cml_gold_tolerance").remove();\n      if(goldDataElem.value.length > 0) {\n        var goldData = jQuery.parseJSON(goldDataElem.value);\n        goldData[0].paths = iaObj.saveLoad.afterJsonPathsConversion(goldData[0].paths)\n        if(goldData.length == 1) {\n          iaObj.saveLoad.missedGoldFromJSONsingleObject(goldData[0],null);\n          iaObj.menu.disableDrawingTools();\n        }\n        else {\n          var judgments = [].concat( goldData );\n\n          judgments.reverse();\n          judgments.pop();\n          judgments.reverse();\n\n          for(var i = 0; i < judgments.length; i++) {\n            judgments[i][0].paths =\n              iaObj.saveLoad.afterJsonPathsConversion(judgments[i][0].paths);\n          }\n          iaObj.saveLoad.missedGoldFromJSONJudgmentOverlay(goldData[0],judgments);\n          iaObj.menu.disableDrawingTools();\n        }\n      }\n      jQuery(\'.cf_action_list.ia_\'+index).remove();\n    }\n    else if( goldDataElem.value !== "" ) {\n      //edit gold with previously saved gold data\n      iaObj.saveLoad.JsonToObjectList( goldDataElem.value );\n      iaObj.core.enableDrawingForObject(0);\n      iaObj.menu.drawCurrentObjPathList();\n      iaObj.undoRedo.saveCPState();\n    }\n    else{\n      //judgment creation or edit gold with no data\n      iaObj.core.fillSingleObjectList();\n      iaObj.core.setCompletedObjects(iaObj.core.getObjectList());\n      iaObj.core.enableDrawingForObject(0);\n      iaObj.menu.drawCurrentObjPathList();\n    }\n    jQuery("#ia_canvas_"+index).fadeIn();\n  }\n\n  // *global*\n  jQuery(\'.ia_container\').on(\'mouseenter\', function() {\n    var pIndex = getProjectIndexFromContainer(jQuery(this).attr("class"));\n    changeActiveInstance(pIndex);\n  });\n\n  // *global*\n  function changeActiveInstance(newIndex) {\n    if(newIndex >= 0 && newIndex < iaInstanceList.length) {\n      paper.project = paper.projects[newIndex];\n      if(iaInstanceList[newIndex].menu.areToolsEnabled()) {\n        iaInstanceList[newIndex].menu.enableActiveTool();\n      }\n      else {\n        iaInstanceList[newIndex].menu.disableActiveTool();\n      }\n      activeInstance = newIndex;\n    }\n  }\n}\n\nvar ia = new ImageAnnotation(jQuery,paper);\n'}}),define("image-annotation",function(){});